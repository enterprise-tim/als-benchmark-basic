<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AsyncLocalStorage Enterprise Performance Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .dashboard {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            color: #7f8c8d;
            font-size: 1.1em;
        }
        
        nav {
            background: rgba(255, 255, 255, 0.95);
            padding: 1rem 0;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 20px;
            z-index: 100;
        }
        
        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .nav-links a {
            text-decoration: none;
            color: #3498db;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .nav-links a:hover {
            background-color: rgba(52, 152, 219, 0.1);
            transform: translateY(-1px);
        }
        
        .nav-links a.active {
            background-color: #3498db;
            color: white;
        }

        .file-upload {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .upload-area {
            border: 3px dashed #3498db;
            border-radius: 15px;
            padding: 40px;
            background: #f8fbff;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #2980b9;
            background: #e3f2fd;
        }

        .upload-area.drag-over {
            border-color: #27ae60;
            background: #e8f5e8;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15);
        }

        .metric-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .metric-value {
            font-size: 2.2em;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .metric-subtitle {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-size: 1.4em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }

        .results-table {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }

        tr:hover {
            background: #f8fbff;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-excellent { background: #27ae60; }
        .status-good { background: #f39c12; }
        .status-warning { background: #e67e22; }
        .status-poor { background: #e74c3c; }

        .hidden {
            display: none;
        }

        .error-message {
            background: #ffe6e6;
            color: #c0392b;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #f8d7da;
        }

        .success-message {
            background: #e8f5e8;
            color: #27ae60;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #d4edda;
        }

        @media (max-width: 768px) {
            .dashboard {
                padding: 10px;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="header">
            <h1>🚀 Enterprise Performance Dashboard</h1>
            <p>AsyncLocalStorage Benchmark Results Analysis</p>
        </div>
        
        <nav>
            <div class="nav-container">
                <ul class="nav-links">
                                    <li><a href="index.html">Performance Dashboard</a></li>
                <li><a href="version-analysis.html">Version Analysis</a></li>
                <li><a href="getting-started.html">Getting Started</a></li>
                <li><a href="nested-als.html">Nested ALS Guide</a></li>
                <li><a href="enterprise-dashboard.html" class="active">Enterprise Dashboard</a></li>
                <li><a href="raw-data.html">Raw Data & Resources</a></li>
                </ul>
            </div>
        </nav>

        <div class="file-upload">
            <h3 style="margin-bottom: 20px; color: #2c3e50;">Load Enterprise Results</h3>
            <div class="upload-area" id="uploadArea">
                <p style="margin-bottom: 15px; font-size: 1.1em;">📊 Drag and drop your enterprise results files here</p>
                <p style="color: #7f8c8d;">Or click to select files from the artifacts download</p>
                <input type="file" id="fileInput" multiple accept=".json" style="display: none;">
            </div>
            <div id="fileStatus"></div>
        </div>

        <div id="dashboardContent" class="hidden">
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-title">🎯 Test Configuration</div>
                    <div class="metric-value" id="testConfig">-</div>
                    <div class="metric-subtitle" id="testTimestamp">-</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">⚡ Runner Performance</div>
                    <div class="metric-value" id="runnerType">-</div>
                    <div class="metric-subtitle" id="systemSpecs">-</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">📈 Best Performance</div>
                    <div class="metric-value" id="bestOverhead">-</div>
                    <div class="metric-subtitle" id="bestNode">-</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">📊 Reliability Score</div>
                    <div class="metric-value" id="reliabilityScore">-</div>
                    <div class="metric-subtitle" id="reliabilityDesc">-</div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">Performance Overhead by Node.js Version</div>
                <canvas id="overheadChart" height="100"></canvas>
            </div>

            <div class="chart-container">
                <div class="chart-title">Statistical Reliability Analysis</div>
                <canvas id="reliabilityChart" height="100"></canvas>
            </div>

            <div class="results-table">
                <h3 style="color: #2c3e50; margin-bottom: 20px;">📋 Detailed Results</h3>
                <table id="resultsTable">
                    <thead>
                        <tr>
                            <th>Node.js Version</th>
                            <th>Benchmark</th>
                            <th>Mean Overhead</th>
                            <th>Std Dev</th>
                            <th>95% CI</th>
                            <th>Reliability</th>
                            <th>Samples</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        class EnterpriseDashboard {
            constructor() {
                this.data = null;
                this.charts = {};
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('drag-over');
            }

            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('drag-over');
            }

            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.json'));
                this.processFiles(files);
            }

            handleFileSelect(e) {
                const files = Array.from(e.target.files).filter(f => f.name.endsWith('.json'));
                this.processFiles(files);
            }

            async processFiles(files) {
                if (files.length === 0) {
                    this.showError('Please select JSON files containing benchmark results.');
                    return;
                }

                try {
                    this.showStatus('Processing files...', 'info');
                    
                    const results = {};
                    
                    for (const file of files) {
                        const content = await this.readFile(file);
                        const data = JSON.parse(content);
                        
                        // Detect file type and process accordingly
                        if (data.benchmarks && Array.isArray(data.benchmarks)) {
                            // Individual benchmark result
                            let nodeVersion = data.nodeVersion || 'unknown';
                            // Clean up version string (remove 'v' prefix if present)
                            nodeVersion = nodeVersion.replace(/^v/, '');
                            if (!results[nodeVersion]) results[nodeVersion] = [];
                            results[nodeVersion].push(data);
                        } else if (data.detailedAnalysis) {
                            // Statistical analysis file
                            results.analysis = data;
                        } else if (data.test_run) {
                            // Dashboard summary file
                            results.summary = data;
                        }
                    }

                    this.data = results;
                    this.generateDashboard();
                    this.showStatus('✅ Dashboard loaded successfully!', 'success');
                    
                } catch (error) {
                    console.error('Error processing files:', error);
                    this.showError('Error processing files: ' + error.message);
                }
            }

            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }

            generateDashboard() {
                // If we don't have analysis data, generate it from individual results
                if (!this.data.analysis && this.hasIndividualResults()) {
                    this.generateAnalysisFromResults();
                }
                
                // Show dashboard content
                document.getElementById('dashboardContent').classList.remove('hidden');
                
                // Update metrics
                this.updateMetrics();
                
                // Generate charts
                this.generateOverheadChart();
                this.generateReliabilityChart();
                
                // Update results table
                this.updateResultsTable();
            }

            hasIndividualResults() {
                return Object.keys(this.data).some(key => 
                    key !== 'analysis' && key !== 'summary' && Array.isArray(this.data[key])
                );
            }

            generateAnalysisFromResults() {
                const analysis = {
                    detailedAnalysis: {}
                };

                // Process each Node.js version
                Object.entries(this.data).forEach(([version, results]) => {
                    if (version === 'analysis' || version === 'summary' || !Array.isArray(results)) return;
                    
                    analysis.detailedAnalysis[version] = {};
                    
                    // Get all benchmark names from first result
                    if (results.length > 0 && results[0].benchmarks) {
                        results[0].benchmarks.forEach((benchmark, idx) => {
                            const benchmarkName = benchmark.name;
                            
                            // Collect overhead values from all iterations
                            const overheadValues = results.map(result => {
                                const bench = result.benchmarks[idx];
                                return bench?.overhead?.timePercent;
                            }).filter(v => v !== undefined && !isNaN(v));
                            
                            if (overheadValues.length > 0) {
                                const stats = this.calculateStatsForValues(overheadValues);
                                analysis.detailedAnalysis[version][benchmarkName] = {
                                    overhead: stats
                                };
                            }
                        });
                    }
                });

                this.data.analysis = analysis;
            }

            calculateStatsForValues(values) {
                if (!values || values.length === 0) return null;

                const sorted = values.slice().sort((a, b) => a - b);
                const n = values.length;
                const sum = values.reduce((a, b) => a + b, 0);
                const mean = sum / n;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
                const stddev = Math.sqrt(variance);
                const median = sorted[Math.floor(sorted.length / 2)];
                const q1 = sorted[Math.floor(sorted.length * 0.25)];
                const q3 = sorted[Math.floor(sorted.length * 0.75)];
                const iqr = q3 - q1;
                const min = Math.min(...values);
                const max = Math.max(...values);
                const cv = (stddev / mean) * 100;

                // 95% confidence interval
                const marginOfError = 1.96 * stddev / Math.sqrt(n);
                const ci95 = {
                    lower: mean - marginOfError,
                    upper: mean + marginOfError
                };

                // Outlier detection using IQR method
                const outlierThresholdLower = q1 - 1.5 * iqr;
                const outlierThresholdUpper = q3 + 1.5 * iqr;
                const outliers = values.filter(v => v < outlierThresholdLower || v > outlierThresholdUpper);

                return {
                    count: n,
                    mean: parseFloat(mean.toFixed(3)),
                    median: parseFloat(median.toFixed(3)),
                    stddev: parseFloat(stddev.toFixed(3)),
                    cv_percent: parseFloat(cv.toFixed(2)),
                    min: parseFloat(min.toFixed(3)),
                    max: parseFloat(max.toFixed(3)),
                    q1: parseFloat(q1.toFixed(3)),
                    q3: parseFloat(q3.toFixed(3)),
                    iqr: parseFloat(iqr.toFixed(3)),
                    confidence_interval_95: {
                        lower: parseFloat(ci95.lower.toFixed(3)),
                        upper: parseFloat(ci95.upper.toFixed(3))
                    },
                    outliers: {
                        count: outliers.length,
                        percentage: parseFloat((outliers.length / n * 100).toFixed(2)),
                        values: outliers.map(v => parseFloat(v.toFixed(3)))
                    }
                };
            }

            updateMetrics() {
                const summary = this.data.summary || {};
                const analysis = this.data.analysis || {};

                // Test configuration
                if (summary.test_run) {
                    document.getElementById('testConfig').textContent = 
                        `${summary.test_run.iterations_per_version || 'N/A'} iterations`;
                    document.getElementById('testTimestamp').textContent = 
                        new Date(summary.test_run.timestamp).toLocaleString() || 'Unknown';
                }

                // Runner type
                if (summary.test_run) {
                    document.getElementById('runnerType').textContent = 
                        summary.test_run.runner_type || 'Standard';
                    document.getElementById('systemSpecs').textContent = 'Enterprise Runner';
                }

                // Best performance
                let bestOverhead = Infinity;
                let bestNode = 'N/A';
                
                if (analysis.detailedAnalysis) {
                    Object.entries(analysis.detailedAnalysis).forEach(([version, benchmarks]) => {
                        Object.entries(benchmarks).forEach(([name, stats]) => {
                            if (stats.overhead && stats.overhead.mean < bestOverhead) {
                                bestOverhead = stats.overhead.mean;
                                bestNode = `Node.js ${version}`;
                            }
                        });
                    });
                }

                document.getElementById('bestOverhead').textContent = 
                    bestOverhead === Infinity ? 'N/A' : `${bestOverhead.toFixed(2)}%`;
                document.getElementById('bestNode').textContent = bestNode;

                // Reliability score
                const reliability = this.calculateReliabilityScore();
                document.getElementById('reliabilityScore').textContent = 
                    `${reliability.score}/100`;
                document.getElementById('reliabilityDesc').textContent = reliability.description;
            }

            calculateReliabilityScore() {
                if (!this.data.analysis || !this.data.analysis.detailedAnalysis) {
                    return { score: 0, description: 'No data available' };
                }

                let totalTests = 0;
                let excellentTests = 0;
                let goodTests = 0;

                Object.values(this.data.analysis.detailedAnalysis).forEach(benchmarks => {
                    Object.values(benchmarks).forEach(stats => {
                        if (stats.overhead) {
                            totalTests++;
                            const cv = stats.overhead.cv_percent || 100;
                            const outliers = stats.overhead.outliers?.percentage || 100;
                            
                            if (cv < 5 && outliers < 5) {
                                excellentTests++;
                            } else if (cv < 10 && outliers < 10) {
                                goodTests++;
                            }
                        }
                    });
                });

                if (totalTests === 0) {
                    return { score: 0, description: 'No test results' };
                }

                const score = Math.round((excellentTests * 100 + goodTests * 75) / totalTests);
                let description = 'Poor reliability';
                
                if (score >= 90) description = 'Excellent reliability';
                else if (score >= 75) description = 'Good reliability';
                else if (score >= 50) description = 'Fair reliability';

                return { score, description };
            }

            generateOverheadChart() {
                const ctx = document.getElementById('overheadChart').getContext('2d');
                
                if (this.charts.overhead) {
                    this.charts.overhead.destroy();
                }

                const chartData = this.prepareOverheadChartData();
                
                this.charts.overhead = new Chart(ctx, {
                    type: 'bar',
                    data: chartData,
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Overhead Percentage (%)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Node.js Version'
                                }
                            }
                        }
                    }
                });
            }

            prepareOverheadChartData() {
                const labels = [];
                const datasets = [];
                const colors = ['#3498db', '#e74c3c', '#f39c12', '#27ae60', '#9b59b6'];

                if (!this.data.analysis || !this.data.analysis.detailedAnalysis) {
                    return { labels: [], datasets: [] };
                }

                // Get all benchmark names
                const benchmarkNames = new Set();
                Object.values(this.data.analysis.detailedAnalysis).forEach(benchmarks => {
                    Object.keys(benchmarks).forEach(name => benchmarkNames.add(name));
                });

                // Prepare datasets for each benchmark
                Array.from(benchmarkNames).forEach((benchmarkName, index) => {
                    const data = [];
                    const nodeVersions = Object.keys(this.data.analysis.detailedAnalysis).sort();
                    
                    if (labels.length === 0) {
                        labels.push(...nodeVersions);
                    }

                    nodeVersions.forEach(version => {
                        const benchmark = this.data.analysis.detailedAnalysis[version][benchmarkName];
                        data.push(benchmark?.overhead?.mean || 0);
                    });

                    datasets.push({
                        label: benchmarkName,
                        data: data,
                        backgroundColor: colors[index % colors.length] + '80',
                        borderColor: colors[index % colors.length],
                        borderWidth: 2
                    });
                });

                return { labels, datasets };
            }

            generateReliabilityChart() {
                const ctx = document.getElementById('reliabilityChart').getContext('2d');
                
                if (this.charts.reliability) {
                    this.charts.reliability.destroy();
                }

                const reliabilityData = this.prepareReliabilityData();
                
                this.charts.reliability = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Excellent', 'Good', 'Fair', 'Poor'],
                        datasets: [{
                            data: reliabilityData,
                            backgroundColor: ['#27ae60', '#f39c12', '#e67e22', '#e74c3c'],
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'bottom',
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = ((context.parsed / total) * 100).toFixed(1);
                                        return `${context.label}: ${context.parsed} tests (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            prepareReliabilityData() {
                const counts = [0, 0, 0, 0]; // excellent, good, fair, poor

                if (!this.data.analysis || !this.data.analysis.detailedAnalysis) {
                    return counts;
                }

                Object.values(this.data.analysis.detailedAnalysis).forEach(benchmarks => {
                    Object.values(benchmarks).forEach(stats => {
                        if (stats.overhead) {
                            const cv = stats.overhead.cv_percent || 100;
                            const outliers = stats.overhead.outliers?.percentage || 100;
                            
                            if (cv < 5 && outliers < 5) {
                                counts[0]++; // excellent
                            } else if (cv < 10 && outliers < 10) {
                                counts[1]++; // good
                            } else if (cv < 20 && outliers < 20) {
                                counts[2]++; // fair
                            } else {
                                counts[3]++; // poor
                            }
                        }
                    });
                });

                return counts;
            }

            updateResultsTable() {
                const tbody = document.querySelector('#resultsTable tbody');
                tbody.innerHTML = '';

                if (!this.data.analysis || !this.data.analysis.detailedAnalysis) {
                    return;
                }

                Object.entries(this.data.analysis.detailedAnalysis).forEach(([version, benchmarks]) => {
                    Object.entries(benchmarks).forEach(([benchmarkName, stats]) => {
                        if (stats.overhead) {
                            const row = tbody.insertRow();
                            
                            // Determine reliability status
                            const cv = stats.overhead.cv_percent || 100;
                            const outliers = stats.overhead.outliers?.percentage || 100;
                            let reliabilityClass = 'status-poor';
                            let reliabilityText = 'Poor';
                            
                            if (cv < 5 && outliers < 5) {
                                reliabilityClass = 'status-excellent';
                                reliabilityText = 'Excellent';
                            } else if (cv < 10 && outliers < 10) {
                                reliabilityClass = 'status-good';
                                reliabilityText = 'Good';
                            } else if (cv < 20 && outliers < 20) {
                                reliabilityClass = 'status-warning';
                                reliabilityText = 'Fair';
                            }

                            row.innerHTML = `
                                <td>${version}</td>
                                <td>${benchmarkName}</td>
                                <td>${stats.overhead.mean?.toFixed(2) || 'N/A'}%</td>
                                <td>${stats.overhead.stddev?.toFixed(2) || 'N/A'}%</td>
                                <td>${stats.overhead.confidence_interval_95 ? 
                                    `[${stats.overhead.confidence_interval_95.lower?.toFixed(2)}, ${stats.overhead.confidence_interval_95.upper?.toFixed(2)}]%` : 'N/A'}</td>
                                <td><span class="status-indicator ${reliabilityClass}"></span>${reliabilityText}</td>
                                <td>${stats.overhead.count || 'N/A'}</td>
                            `;
                        }
                    });
                });
            }

            showError(message) {
                const status = document.getElementById('fileStatus');
                status.innerHTML = `<div class="error-message">❌ ${message}</div>`;
            }

            showStatus(message, type = 'info') {
                const status = document.getElementById('fileStatus');
                const className = type === 'success' ? 'success-message' : 'error-message';
                status.innerHTML = `<div class="${className}">${message}</div>`;
                
                if (type === 'success') {
                    setTimeout(() => status.innerHTML = '', 3000);
                }
            }
        }

        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new EnterpriseDashboard();
        });
    </script>
</body>
</html>
